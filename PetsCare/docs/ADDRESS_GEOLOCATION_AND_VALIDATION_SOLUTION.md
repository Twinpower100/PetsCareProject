# Геокодирование и валидация адресов: целевое решение и бизнес-цели

Документ описывает **целевое решение (без кода)** для геокодирования и валидации адресов в продукте PetsCare: единый поток, согласованная семантика полей и бизнес-цели по типам адресов.

**Ключевые принципы целевой картины:**

- Все адреса (модель Address) **не создаются в админке Django**. Они приходят только из основного фронта (юр. адрес организации, адрес пользователя/ситтера) или из админки для провайдеров (адреса точек предоставления услуг — локации).
- **Ручная валидация не предусмотрена.** Если пришедший адрес не прошёл автоматическую валидацию, система возвращает ошибку и **не сохраняет** адрес. В БД не должно быть адресов в состоянии **pending** — сохраняем только успешно провалидированные (valid) или явно invalid/error при необходимости логирования.
- У пользователя (клиента) **нет сущности «адрес»** (Address). Для сценария «Поиск рядом со мной» нужны только **координаты (point)** — с устройства (GPS) или выбора на карте (например, UserLocation или lat/lon в запросе), а не сохранённый структурированный адрес.

---

## 1. Текущие проблемы (почему «пошли нецелевым путём»)

### 1.1 Несколько независимых способов «валидации»

- **validation_status** (pending / valid / invalid / error) — выставляется в разных местах: в `AddressValidationService._save_validation_result()`, в `_update_address_from_geocoding` / `_update_address_from_cache`, в админке (action «Clear validation status»), в views при ручном обновлении полей после вызова сервиса, в `users/signals` при одобрении заявки провайдера.
- **is_valid** (bool) — выставляется **только** в `_save_validation_result()`. Если адрес создан/обновлён через админку провайдера (выбор или создание Address без вызова сервиса), это поле остаётся `False`.
- **is_geocoded** (bool) — в коде задаётся как `bool(address.point)`. Поскольку **point** в сервисе геолокации нигде не заполняется (см. ниже), после валидации через `AddressValidationService` значение остаётся `False`, даже при заполненных latitude/longitude.
- **is_validated** (bool) — legacy-флаг, дублирует смысл «валидация уже выполнялась»; тоже выставляется только в сервисе.

Итог: при создании адреса через админку провайдера (локация/юр. адрес) validation_status могли выставить вручную или он остался pending, а is_valid / is_geocoded не проставляются, потому что единственное место их установки — `_save_validation_result()`, которое вызывается только при явном запуске валидации через сервис.

### 1.2 Point не сохраняется

- В **geolocation/services.py** в методах `_update_address_from_geocoding()` и `_update_address_from_cache()` обновляются только **latitude**, **longitude**, **formatted_address**, **geocoding_accuracy**, компоненты адреса и validation_status. Поле **point** (PostGIS) нигде не устанавливается.
- В `_save_validation_result()` вычисляется `is_geocoded = bool(address.point)` — при пустом point получаем всегда False.
- Поиск провайдеров/локаций по радиусу в **providers** строится по `structured_address__point` (например, `structured_address__point__isnull=False`). Адреса без point исключаются из геопоиска, даже если latitude/longitude заполнены.

Исключение: в **users/signals** при одобрении заявки провайдера при создании Address из `address_components` и при геокодировании через Google Maps **point явно выставляется** (и lat/lon тоже). Там поток согласован.

### 1.3 Разные точки входа без единого контракта

- **Создание/редактирование адреса в админке** (в т.ч. при создании провайдера/локации): сохранение модели Address без вызова `AddressValidationService`. Координаты и статус могут быть введены вручную, point при этом не заполняется, is_valid/is_geocoded не пересчитываются.
- **Действие в админке «Validate selected addresses»**: вызывается `AddressValidationService.validate_address()`; сервис обновляет lat/lon и статусы, но не заполняет point, поэтому is_geocoded остаётся False.
- **API** (например, POST validate или bulk validate в geolocation/views): в коде ожидается объект с атрибутами `is_valid`, `formatted_address`, `latitude`, `longitude`, тогда как `validate_address()` возвращает только **bool** — это несогласованность контракта (риск ошибок при вызове).
- **Одобрение заявки провайдера** (users/signals): создаётся Address, при наличии координат выставляются point, lat, lon, validation_status — поток корректен для этого сценария.

Итог: «целевым путём» должен быть **один понятный поток**: при появлении у адреса координат (из API геокодирования или ручного ввода) всегда синхронизировать point и сводные флаги, а статус валидации определять в одном месте.

---

## 2. Целевое решение (без кода)

### 2.1 Единый источник правды для состояния адреса

- **Каноническое поле состояния**: **validation_status**. В целевой картине **pending не используется как сохраняемое состояние**: адрес либо сохраняется уже провалидированным (valid), либо не сохраняется (при ошибке валидации клиенту возвращается ошибка). Допустимые значения в БД: **valid**, **invalid**, **error** (если нужно сохранять факт неуспешной проверки для логов).
- **Правила согласованности**:
  - Если есть координаты (latitude и longitude заданы), то в БД должен быть заполнен и **point** (при сохранении Address с lat/lon всегда строить point и сохранять).
  - **is_geocoded** = «есть точка» = (point не null).

Рекомендация: при сохранении Address синхронизировать latitude/longitude → point (Point(lon, lat, srid=4326)) и is_geocoded = (point is not null). Для статуса валидации достаточно одного поля **validation_status** (см. ниже про is_valid / is_validated).

### 2.2 Откуда приходят адреса и как они валидируются

- **Адреса не создаются в админке Django.** Единственные источники создания/обновления Address:
  - **Основной фронт (petcare-web-new)**: юр. адрес организации, адрес пользователя (в т.ч. ситтера). Клиент отправляет данные адреса; бэкенд валидирует и только при успехе сохраняет.
  - **Админка для провайдеров (petscare-web-admin)**: адреса точек предоставления услуг (ProviderLocation.structured_address). Создание/редактирование адреса локации только через этот фронт; бэкенд валидирует и при успехе сохраняет.
- **Валидация только автоматическая.** Ручной режим («валидировать выбранные адреса» в админке Django и т.п.) в целевой картине не предусмотрен. Поток: клиент (фронт или админка провайдеров) отправляет адрес → бэкенд выполняет геокодирование/валидацию → при **успехе** сохраняет Address (с point и validation_status = 'valid') → при **неуспехе** возвращает ошибку и **не сохраняет** адрес. В БД не должно быть адресов в состоянии pending.
- **Единственный сервис операций**: **AddressValidationService** (или обёртка) выполняет геокодирование, заполняет координаты **и point**, выставляет validation_status. Все точки входа (API основного фронта, API админки провайдеров, при необходимости одобрение заявки) вызывают этот сервис **до** сохранения; сохранение только при validation_status = 'valid' (или явном решении сохранять invalid/error для аудита).
- **Одобрение заявки провайдера** (users/signals): при создании Address из заявки — тот же принцип: валидация до сохранения, point и флаги согласованы; не сохранять в pending.

### 2.3 Исправление текущего кода (на уровне требований)

- В **geolocation/services.py** в `_update_address_from_geocoding` и `_update_address_from_cache`: при установке latitude/longitude всегда создавать и сохранять **point** (Point(longitude, latitude, srid=4326)).
- При любом сохранении Address — единая логика: latitude/longitude → point; is_geocoded = (point is not null); validation_status задаётся по результату валидации (valid / invalid / error).
- API создания/обновления адреса: **не сохранять** адрес, если валидация не прошла; возвращать клиенту ошибку. Не допускать сохранения с validation_status = 'pending'.
- Привести в соответствие **views** (validate action, bulk validate): контракт с `AddressValidationService.validate_address()` — возвращается bool; при неуспехе не сохранять; при успехе возвращать данные из сохранённого address.

Итог: адреса создаются только из основного фронта и админки провайдеров; валидация только автоматическая перед сохранением; pending не храним; point всегда заполняется при наличии координат.

---

## 3. Бизнес-цели полей и по типам адресов

### 3.1 Назначение полей модели Address

| Поле | Бизнес-цель |
|------|-------------|
| **validation_status** | **Единственный нужный для продукта признак результата валидации.** Допустимые значения в БД: **valid**, **invalid**, **error** (pending не храним). Для управленца, пользователей и логики достаточно одного поля: «адрес пригоден к использованию» = (validation_status == 'valid'). Фильтры, отчёты, решение «показывать в поиске» — по нему. |
| **is_valid** / **is_validated** | **Для продукта и управленца разницы и ценности нет — два поля избыточны.** Оба по смыслу дублируют validation_status: is_valid = (status == 'valid'), is_validated = «проверяли» (при отказе от pending всегда true у сохранённых). Рекомендация: считать **legacy**, не использовать в новой логике; при чтении при необходимости вычислять из validation_status; в перспективе — убрать из модели и оставить только validation_status. |
| **is_geocoded** | «Есть координаты для карты и геопоиска». True тогда и только тогда, когда заполнен **point**. |
| **point** | Геометрия для поиска по радиусу, сортировки по расстоянию и отображения на карте. Обязателен для сценариев «поиск рядом» по провайдерам/ситтерам. |
| **latitude / longitude** | Человекочитаемые координаты, API, отображение. Синхронны с point при наличии координат. |
| **formatted_address** | Единая строка адреса для отображения и печати. |
| **geocoding_accuracy** | Качество геокодирования (ROOFTOP / RANGE_INTERPOLATED и т.д.) — для аналитики. |

### 3.2 Типы адресов в продукте и требования

В коде используются следующие привязки к **geolocation.Address** (structured_address):

| Тип адреса | Модель / связь | Источник данных | Валидация | point | Бизнес-цель |
|------------|----------------|------------------|-----------|-------|-------------|
| **Юридический адрес провайдера** | Provider.structured_address | Основной фронт (или заявка провайдера при одобрении). | Обязательна перед сохранением. | Не обязательна для геопоиска (поиск по локациям). | Реквизиты, контракты, доверие. |
| **Адрес локации оказания услуг** | ProviderLocation.structured_address | Админка для провайдеров. | Обязательна перед сохранением. | **Обязательна.** Поиск по радиусу идёт по `structured_address__point`. | Карта, «рядом со мной», расстояние до клиента. |
| **Адрес ситтера (место передержки)** | SitterProfile.structured_address | Основной фронт. | Обязательна перед сохранением. | **Обязательна** для поиска ситтеров по расстоянию. | Поиск ситтеров «рядом», карта, расстояние. |
| **Адрес из заявки провайдера** | При одобрении создаётся Address, привязывается к Provider/локации. | Заявка → одобрение (бэкенд). | При создании Address — та же: валидация до сохранения. | Если адрес станет адресом локации — обязателен. | Перенос адреса из заявки в карточку провайдера/локации. |

**Пользователь (клиент): адреса как сущности Address нет.** Хранить структурированный адрес клиента (улица, дом, город) не требуется. Для сценария **«Поиск рядом со мной»** нужны только **текущие координаты пользователя (point)** — с устройства (GPS) или выбора на карте. Они передаются в запросе (lat/lon) или хранятся, например, в UserLocation (point), но не как запись Address. То есть центр поиска «рядом со мной» — это координаты (point), а не валидированный адрес клиента.

---

## 4. Резюме рекомендаций

1. **Источники адресов**: адреса (Address) создаются только из **основного фронта** (юр. адрес организации, адрес пользователя/ситтера) и из **админки для провайдеров** (адреса локаций). Админка Django не используется для создания адресов.
2. **Валидация только автоматическая**: ручная валидация не предусмотрена. При приходе адреса бэкенд валидирует его; при успехе — сохраняет (с point и validation_status = 'valid'); при неуспехе — возвращает ошибку и не сохраняет. **validation_status = pending в БД не храним.**
3. **Один признак валидации**: для продукта достаточно **validation_status** (valid / invalid / error). Поля **is_valid** и **is_validated** для управленца и пользователей не несут отдельной ценности — считать legacy, в новой логике опираться только на validation_status. При сохранении Address с координатами всегда заполнять **point** и is_geocoded; статус задаётся validation_status.
4. **Клиент (пользователь услуг)**: сущности «адрес пользователя» (Address) нет. Для «Поиск рядом со мной» нужны только **координаты (point)** пользователя — с устройства или с карты (параметры запроса или UserLocation), а не сохранённый структурированный адрес.
5. **Устранить расхождения**: в сервисе геолокации при установке lat/lon всегда записывать point; API не сохранять адрес при неуспешной валидации и не допускать pending в БД.

После внедрения этих правил геопоиск по провайдерам и ситтерам будет учитывать все сохранённые адреса с заполненным point, а сценарий «рядом со мной» будет опираться на координаты пользователя, а не на запись Address.

---

## 5. Частые вопросы

### 5.1 Очистка данных перед реализацией

**Адреса, провайдеры, локации провайдеров, заявки провайдеров и т.д. управляющий/пользователь удаляет из БД по своему решению.** Реализация не требует обязательной очистки: схему под старые записи мы не ломаем. Если решите начать с пустой базы — удаляйте; если оставите данные — после внедрения кода можно один раз дозаполнить **point** по имеющимся lat/lon у существующих Address (management-команда или миграция данных), чтобы они участвовали в геопоиске.

### 5.2 Модели Location, LocationHistory, SearchRadius (geolocation)

**Удалены.** В продукте не использовались: нет API и бизнес-логики по ним; «текущая позиция пользователя» и «поиск рядом со мной» закрыты **UserLocation** и эндпоинтами device-location / map-location / user-location; структурированные адреса — **Address**. Модели Location, LocationHistory, SearchRadius из приложения geolocation удалены из кода и из БД (миграция 0007).
