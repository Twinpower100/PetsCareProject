# Анализ уникальности email и телефона для провайдеров

## Текущая ситуация

### Модель User
- `email` - `unique=True` (глобально уникален)
- `phone` - `unique=True` (глобально уникален)

### Модель Provider
- `email` - `unique=True` (глобально уникален)
- `phone_number` - `unique=True` (глобально уникален)
- `name` - `unique=True` (глобально уникален)

### Модель ProviderForm
- `provider_email` - **НЕТ unique constraint**
- `provider_phone` - **НЕТ unique constraint**

### Текущая проверка в ProviderFormSerializer
- Проверяется уникальность email/телефона только в модели `Provider`
- **НЕ проверяется** в модели `User` (хотя там тоже unique=True)
- **НЕ проверяется** в модели `ProviderForm` (нет unique constraints)

## Проблема

**Сценарий**: Провайдер - это ИП (индивидуальный предприниматель)
- ИП регистрируется как обычный пользователь (`User`) с email `ivan@example.com`
- Потом ИП хочет зарегистрироваться как провайдер (`Provider`) с тем же email `ivan@example.com`
- **Текущая реализация**: Это **НЕ сработает**, так как в модели `Provider` email имеет `unique=True`, но Django не проверяет конфликт с `User.email`

**Но на самом деле**: Django ORM проверяет уникальность только в рамках одной таблицы. Если в `User` есть `unique=True` на email, а в `Provider` тоже `unique=True` на email, они могут иметь **разные значения**, но **не могут иметь одинаковые значения в рамках каждой таблицы**.

## Вопрос пользователя

> Email и телефон должны быть уникальны на уровне заявок/провайдеров, а не вообще уникальности на уровне всех возможных номеров и имейлов системы

**То есть**:
- Email/телефон должны быть уникальны среди `Provider` и `ProviderForm`
- Email/телефон **могут совпадать** с email/телефоном обычных пользователей (`User`)

## Решение: ДА, это возможно!

### Вариант 1: Убрать `unique=True` из модели Provider (рекомендуется)

**Изменения**:
1. Убрать `unique=True` из полей `email` и `phone_number` в модели `Provider`
2. Добавить проверку уникальности в сериализаторе `ProviderFormSerializer`:
   - Проверять в `Provider` (уже созданные провайдеры)
   - Проверять в `ProviderForm` (заявки)
   - **НЕ проверять** в `User` (разрешить совпадение)
3. Добавить `UniqueConstraint` в модель `ProviderForm` для email и phone
4. При создании `Provider` из `ProviderForm` - проверять уникальность только среди провайдеров

**Преимущества**:
- ✅ Email/телефон провайдера могут совпадать с email/телефоном пользователя
- ✅ Email/телефон уникальны среди провайдеров
- ✅ Гибкая логика проверки

**Недостатки**:
- ⚠️ Нужна миграция для удаления unique constraints
- ⚠️ Нужно добавить проверку в сериализаторе и при создании Provider

### Вариант 2: Оставить `unique=True`, но изменить логику проверки

**Изменения**:
1. Оставить `unique=True` в модели `Provider`
2. В сериализаторе `ProviderFormSerializer` проверять:
   - В `Provider` (уже созданные провайдеры)
   - В `ProviderForm` (заявки)
   - **НЕ проверять** в `User` (разрешить совпадение)
3. При создании `Provider` из `ProviderForm`:
   - Если email/телефон уже есть в `User` - это нормально (ИП)
   - Если email/телефон уже есть в `Provider` - ошибка

**Проблема**: Если в `Provider` есть `unique=True`, Django не позволит создать провайдера с email, который уже есть в `User`, даже если мы не проверяем это в сериализаторе. **Это не сработает!**

### Вариант 3: Использовать составной unique constraint

**Изменения**:
1. Убрать `unique=True` из полей `email` и `phone_number` в модели `Provider`
2. Добавить `UniqueConstraint` на уровне модели:
   ```python
   class Meta:
       constraints = [
           models.UniqueConstraint(
               fields=['email'],
               name='unique_provider_email',
               condition=Q(is_active=True)  # Только для активных провайдеров
           ),
           models.UniqueConstraint(
               fields=['phone_number'],
               name='unique_provider_phone',
               condition=Q(is_active=True)
           ),
       ]
   ```
3. В сериализаторе проверять уникальность среди провайдеров и заявок

**Преимущества**:
- ✅ Гибкая логика (можно сделать уникальность только для активных провайдеров)
- ✅ Email/телефон могут совпадать с пользователями

**Недостатки**:
- ⚠️ Сложнее реализация
- ⚠️ Нужна миграция

## Рекомендация

**Вариант 1** - самый простой и понятный:
1. Убрать `unique=True` из `Provider.email` и `Provider.phone_number`
2. Добавить проверку в сериализаторе (только среди провайдеров и заявок)
3. Добавить `UniqueConstraint` в `ProviderForm`

## Вопросы для уточнения

1. **Может ли один пользователь быть провайдером?**
   - Если да, то email/телефон провайдера = email/телефон пользователя (ИП)
   - Если нет, то можно оставить `unique=True` в Provider

2. **Нужна ли проверка уникальности email/телефона среди заявок?**
   - Если да, то нужно добавить `UniqueConstraint` в `ProviderForm`
   - Если нет, то можно разрешить несколько заявок с одним email/телефоном

3. **Что делать, если пользователь с email `ivan@example.com` уже существует, и создается заявка с тем же email?**
   - Вариант А: Разрешить (ИП регистрируется как провайдер)
   - Вариант Б: Запретить (нужно использовать другой email для провайдера)

## Вывод

**ДА, это возможно реализовать!** 

Нужно:
1. Убрать `unique=True` из `Provider.email` и `Provider.phone_number`
2. Добавить проверку уникальности в сериализаторе (только среди провайдеров и заявок)
3. Добавить `UniqueConstraint` в `ProviderForm` для предотвращения дубликатов заявок

Это позволит:
- ✅ Email/телефон провайдера могут совпадать с email/телефоном пользователя (ИП)
- ✅ Email/телефон уникальны среди провайдеров
- ✅ Email/телефон уникальны среди заявок

